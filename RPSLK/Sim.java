import java.util.Arrays;
import java.util.Scanner;

/**
 * The Sim class either simulates a human player or allows a human player to
 * play the game. The simulated human player will have two different strategies
 * available and one is chosen at random if the human player selects the sim
 * game mode at the start of the game. If no sim mode is chosen, then the human
 * player will play the game as a HumanSim.
 * 
 * There are three Sim subclasses: 
 * 1. RotatorSim: Generates a move in a set order of valid moves. In this case, 
 * the set order is {R, P, S, L, K}. It will continue to throw moves in this 
 * order and repeat once it has reached the end.
 * 2. RefelctorSim: Generates the last move played by the opponent. 
 * 3. HumanSim: Generates the move decided by a human player's input.
 * 
 * @author Alex Yu ajy2116
 */
public class Sim {

	/**
	 * This method generates the next move for the sim/human player based upon what
	 * mode is chosen for the game. If the player selects human player mode, then
	 * HumanSim is always chosen. If the player selects Sim mode, then either
	 * RotatorSim or ReflectorSim will be chosen randomly by the Runner class at the
	 * start of the game.
	 * 
	 * @param record the record class object to access records
	 * @param round  the current round
	 * @return returns the generated move for the sim/human player
	 */
	public String generateNextMove(Records record, int round) {
		return Handle.validMoves[0];
	}
}

/**
 * The RotatorSim class generates the next move based on a preset order of valid
 * moves. The preset order is specified in the Handle class. It will play the
 * moves in order continuously until the game is finished.
 */
class RotatorSim extends Sim {

	public String generateNextMove(Records record, int round) {
		// This is used for AlphaGoThrower testing purposes.
		// return "R";
		return Handle.validMoves[round % Handle.validMoves.length];
	}
}

/**
 * The ReflectorSim class plays the opponent's last move. If the opponent has no
 * last move because it is the first round of the game, then a random move will
 * be chosen from a list of valid moves taken from the Handle class.
 */
class ReflectorSim extends Sim {

	public String generateNextMove(Records record, int round) {
		if (record.cpuMoveHistory.isEmpty() == true) {
			// To generate a random move at the first round when the opponent has no last
			// played move
			int randomMoveCode = (int) (Math.random() * Handle.validMoves.length);
			return Handle.validMoves[randomMoveCode % Handle.validMoves.length];
		} else {
			return record.cpuMoveHistory.get(round - 1);
		}
	}
}

/**
 * The HumanPlayer class allows a human to play against the cpu. The move is
 * generated by the human player's input at each round of the game.
 */
class HumanPlayer extends Sim {
	Scanner scan = new Scanner(System.in);
	String playerMove;

	public String generateNextMove(Records record, int round) {
		System.out.println("Enter your move:");
		System.out.println("R (Rock) - P (Paper) - S(Scissors) - K(Spock) - L(Lizard)");
		boolean validMove = false;

		while (validMove == false) {
			playerMove = scan.next();
			if (Arrays.asList(Handle.validMoves).contains(playerMove) == false) {
				System.out.println("Please enter a valid move.");
			} else {
				validMove = true;
			}
		}
		return playerMove;
	}
}